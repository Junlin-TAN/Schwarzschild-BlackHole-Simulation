<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebGL Black Hole Simulation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
    </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);


    const BLACK_HOLE_MASS = 0.5;
    const Rs = 2.0 * BLACK_HOLE_MASS;
    const DISK_INNER_RADIUS = 1.55 * Rs;
    const DISK_OUTER_RADIUS = 10.0 * Rs;
    const DISK_THICKNESS = 0.3;

    let distance = 10.0;
    let yaw = 0;
    let pitch = Math.PI / 18;
    let mouse = { x: 0, y: 0, isDown: false };


    const loader = new THREE.CubeTextureLoader();
    loader.setPath('image/'); 
    const skyboxTexture = loader.load([
        'right.png', 'left.png',
        'top.png', 'bottom.png',
        'back.png', 'front.png'
    ]);

    // --- Uniforms ---
    const uniforms = {
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_time: { value: 0.0 },
        u_camera_pos: { value: new THREE.Vector3() },
        u_camera_fwd: { value: new THREE.Vector3() },
        u_camera_up: { value: new THREE.Vector3() },
        u_camera_right: { value: new THREE.Vector3() },
        M: { value: BLACK_HOLE_MASS },
        DISK_INNER_RADIUS: { value: DISK_INNER_RADIUS },
        DISK_OUTER_RADIUS: { value: DISK_OUTER_RADIUS },
        DISK_THICKNESS: { value: DISK_THICKNESS },
        u_skybox: { value: skyboxTexture } // 将加载好的纹理传递给着色器
    };

    // --- 创建平面和着色器材质 ---
    const geometry = new THREE.PlaneGeometry(2, 2);
    const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
        fragmentShader: `
            precision highp float;

            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec3 u_camera_pos;
            uniform vec3 u_camera_fwd;
            uniform vec3 u_camera_up;
            uniform vec3 u_camera_right;
            
            uniform float M;
            uniform float DISK_INNER_RADIUS;
            uniform float DISK_OUTER_RADIUS;
            uniform float DISK_THICKNESS;
            
            // 关键修改 #2: 声明天空盒 uniform
            uniform samplerCube u_skybox;

            #define Rs (2.0 * M)
            const float PI = 3.1415926535;
            const float BOUNDARY = 50.0;
            const int MAX_STEPS = 450;
            const float DT = 0.08;

            // 关键修改 #3: 恢复 get_sky_color 的功能
            vec3 get_sky_color(vec3 dir) {
                // WebGL的textureCube和桌面OpenGL的texture函数用法一致
                // 坐标系可能需要微调，但通常(x, y, -z)是兼容的
                return textureCube(u_skybox, vec3(dir.x, dir.y, -dir.z)).rgb;
            }
            
            float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }
            float noise(vec2 st) {
                vec2 i = floor(st); vec2 f = fract(st);
                float a = random(i); float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0)); float d = random(i + vec2(1.0, 1.0));
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.y * u.x;
            }
            float fbm(vec2 st) {
                float value = 0.0; float amplitude = 0.5;
                for (int i = 0; i < 4; i++) {
                    value += amplitude * noise(st); st *= 2.0; amplitude *= 0.5;
                }
                return value;
            }

            vec3 get_disk_color(vec3 pos, vec3 ray_dir) {
                float r = length(pos.xz);
                if (r < DISK_INNER_RADIUS || r > DISK_OUTER_RADIUS) return vec3(0.0);
                float vertical_falloff = 1.0 - smoothstep(0.0, DISK_THICKNESS, abs(pos.y));
                if (vertical_falloff <= 0.0) return vec3(0.0);
                
                float phi = atan(pos.z, pos.x);
                float animated_phi = phi + u_time * 0.2 / (r * 0.5);
                vec2 base_coord = vec2(cos(animated_phi), sin(animated_phi)) * r * 0.3;
                
                vec2 warp_coord1 = base_coord + vec2(u_time * 0.1, 0.0);
                vec2 warp_coord2 = base_coord + vec2(0.0, u_time * 0.08);
                vec2 warp_offset = vec2(fbm(warp_coord1), fbm(warp_coord2));
                float noise_val = fbm(base_coord + warp_offset * 0.5);
                
                noise_val = pow(noise_val, 2.5);
                float temp = 1.0 - smoothstep(DISK_INNER_RADIUS, DISK_OUTER_RADIUS, r);
                temp = pow(temp, 2.0);

                float v_mag = 0.35 * pow(r, -0.5);
                vec3 v_dir = normalize(vec3(-pos.z, 0.0, pos.x));
                vec3 disk_velocity = v_mag * v_dir;
                float grav_redshift = sqrt(1.0 - 1.5 * Rs / r);
                float doppler_dot = dot(disk_velocity, ray_dir);
                float doppler_factor = sqrt(1.0 - v_mag*v_mag) / (1.0 - doppler_dot);
                
                vec3 color_bright = vec3(temp * 1.0, temp * 1.0, temp * 25.0);
                vec3 color_dark = vec3(temp * 1.0, temp * 1.0, temp * 20.0);

                float mix_factor = smoothstep(0.4, 1.6, doppler_factor);
                vec3 base_color = mix(color_dark, color_bright, mix_factor) * noise_val;

                float brightness = pow(doppler_factor, 10.0);
                return base_color * brightness * grav_redshift * vertical_falloff;
            }

            vec3 get_acceleration(vec3 pos) { 
                float r = length(pos); 
                return -1.5 * Rs * pos / (r * r * r * r); 
            }

            vec3 tonemap_aces(vec3 x) {
                float a = 2.51; float b = 0.03; float c = 2.43;
                float d = 0.59; float e = 0.14;
                return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);
            }

            void main() {
                vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
                vec3 ray_dir = normalize(u_camera_fwd + uv.x * u_camera_right + uv.y * u_camera_up);
                vec3 ray_pos = u_camera_pos;
                vec3 velocity = ray_dir;
                
                bool hit_horizon = false;
                vec3 accumulated_light = vec3(0.0);
                float transparency = 1.0;

                for (int i = 0; i < MAX_STEPS; ++i) {
                    float r = length(ray_pos);
                    if (r < Rs) { hit_horizon = true; break; }
                    if (r > BOUNDARY) { break; }

                    float r_disk = length(ray_pos.xz);
                    if (abs(ray_pos.y) < DISK_THICKNESS && r_disk >= DISK_INNER_RADIUS && r_disk < DISK_OUTER_RADIUS) {
                        vec3 step_color = get_disk_color(ray_pos, normalize(velocity)) * DT * 10.0;
                        accumulated_light += step_color * transparency;
                        
                        float opacity = clamp(dot(step_color, vec3(0.333)) * 0.1, 0.0, 1.0);
                        transparency *= (1.0 - opacity);

                        if (transparency < 0.01) { break; }
                    }
                    
                    velocity += DT * get_acceleration(ray_pos);
                    ray_pos += DT * velocity;
                }

                vec3 background_srgb = vec3(0.0, 0.0, 0.0);
                if (!hit_horizon) {
                    background_srgb = get_sky_color(normalize(velocity));
                }

                vec3 background_linear = pow(background_srgb, vec3(2.2));
                vec3 tonemapped_disk_linear = tonemap_aces(accumulated_light);
                vec3 final_linear = mix(background_linear, tonemapped_disk_linear, 1.0 - transparency);
                vec3 final_color = pow(final_linear, vec3(1.0/2.2));
                
                gl_FragColor = vec4(final_color, 1.0);
            }
        `
    });
    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);

    // --- 动画循环 (保持不变) ---
    function animate(time) {
        requestAnimationFrame(animate);
        uniforms.u_time.value = time / 1000.0;
        const cam_x = distance * Math.cos(pitch) * Math.sin(yaw);
        const cam_y = distance * Math.sin(pitch);
        const cam_z = distance * Math.cos(pitch) * Math.cos(yaw);
        uniforms.u_camera_pos.value.set(cam_x, cam_y, cam_z);
        const target = new THREE.Vector3(0, 0, 0);
        const cam_fwd = new THREE.Vector3().subVectors(target, uniforms.u_camera_pos.value).normalize();
        const global_up = new THREE.Vector3(0, 1, 0);
        const cam_right = new THREE.Vector3().crossVectors(cam_fwd, global_up).normalize();
        const cam_up = new THREE.Vector3().crossVectors(cam_right, cam_fwd);
        uniforms.u_camera_fwd.value = cam_fwd;
        uniforms.u_camera_right.value = cam_right;
        uniforms.u_camera_up.value = cam_up;
        renderer.render(scene, camera);
    }
    animate(0);

    // --- 事件监听 (保持不变) ---
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.u_resolution.value.x = window.innerWidth;
        uniforms.u_resolution.value.y = window.innerHeight;
    });
    window.addEventListener('mousedown', () => { mouse.isDown = true; });
    window.addEventListener('mouseup', () => { mouse.isDown = false; });
    window.addEventListener('mousemove', (event) => {
        if (mouse.isDown) {
            yaw += event.movementX * 0.005;
            pitch -= event.movementY * 0.005;
            pitch = Math.max(-Math.PI/2 + 0.01, Math.min(pitch, Math.PI/2 - 0.01));
        }
    });
    window.addEventListener('wheel', (event) => {
        distance += event.deltaY * 0.01;
        distance = Math.max(2.0 * BLACK_HOLE_MASS * 2.5, Math.min(distance, 50.0));
    });

</script>
</body>
</html>```


